[Mysql知识点](https://www.cnblogs.com/bigben0123/p/11233424.html "Mysql知识点")
#### 事务的四个特性 (ACID)
* 原子性：事务是数据库的逻辑工作耽误，事务中包含的各操作要么都做，要么都不做
* 一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态
* 隔离性：一个事务的执行不会干扰到其他事务的执行
* 持续性：也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的，其他操作或故障不会对其执行的结果有任何影响

----------------------------------
#### Mysql的四种隔离级别
* Read Uncommitted(未提交读)：事务中的修改，即使没有提交，其他事务也可以看得到，会导致 '脏读'，'幻读'和'不可重复读取'
* Read Committed(提交读)：大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个串行事务已修改但未提交的数据避免了'脏读'，但不能避免'幻读'和'不可重复读取'
* Repeatable read(重复读)：保证了一个事务不会修改已经由另一个事务读取但未提交(回滚)的数据，避免了'脏读'和'不可重复读',但不能避免'幻读'，但是带来了更多的性能损失
* Serializable(串行化)：最严格的级别，事务串行执行，资源消耗最大
* Lost to modify(丢失修改)：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据
//////////////////////////////////////////////////////////////////////////////////////
* 脏读：所谓脏读，就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。
* 不可重复读：事务A首先读取了一条数据，数据执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复度
* 幻读：事务A首先根据条件筛选得到N条数据，然后事务B改变了这N跳数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，这就是幻读，也就是说，当前事务度第一次渠道的数据比后来读取的数据条目少
* 不可重复度和幻读比较：两者有些相似，但是前者针对的是update或delete，后者针对的是insert

----------------------------------
#### MyISAM和InnoDB区别
Mysql5.5版本之前，默认数据库引擎是MyISAM,5.6之后默认引擎是InnoDB。
MyISAM虽然虽然性能极佳，而且提供了大量的特性，包括全文索引，压缩，空间函数等，但是MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。
两者对比：
* 是否支持行级锁：MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。
* 是否支持事务和崩溃后的安全恢复：MyISAM不支持.但是InnoDB支持事务，回滚和崩溃修复。
* 是否支持外键：MyISAM不支持，而InnoDB支持。
* 是否支持MVCC：仅InnoDB支持，应对高并发事务，MVCC比单纯的加锁更高效，MVCC只在READ COMMITTED和REPEATABLE READ两个隔离级别工作,MVCC可以使用乐观锁和悲观所来实现，各数据库中MVCC实现并不统一。
* MVCC：Multi-Version Concurrency Control,多版本并发控制，提供并发访问数据库时，对事务内读取的到的内存做处理，用来避免写操作堵塞读操作的并发问题。可以通过乐观锁和悲观锁进行实现，乐观锁一般使用版本号机制或CAS算法实现。
* 乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
* 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
* MyISAM采用表级锁(table-level locking)，InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁.
* 表级锁：Mysql中锁定力度最大的一种所，对当前操作的整张表加所，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定力度最大，触发锁冲突的概率最高，并发度最低，MyISAM和InnoDB引擎都支持。
* 行级锁：Mysql中锁定力度最小的一种锁，只针对当前操作的行进行加锁，行级锁能大大减少数据库操作的冲突，其加所粒度最小，并发度最高，但加所的开销也最大，加锁慢，会出现死锁。
####InnoDB存储引擎锁的算法有三种
* Record lock：单个行记录的锁
* Gap lock：间隙锁，锁定一个范围，不包括记录本身
* 采用Next-Key Lock的锁定技术称为Next-Key Locking。这种设计的目的是为了解决幻读（Phantom Problem）。利用这种锁定技术，锁定的不是单个值，而是一个范围。
#####相关知识点
* innodb对于行的查询使用next-key lock
* next-key lock 为了解决幻读问题
* 当查询的索引含有一唯一属性时，将next-key lock 降级为record-key
* Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，目的是为了防止幻读，其主要通过两个方面实现这个目的：
（1）防止间隙内有新数据被插入。
（2）防止已存在的数据，更新成间隙内的数
* Next-Key Lock是结合了Gap Lock和Record Lock的一种锁定算法，在Next-Key Lock算法下，innodb对于行的查询都是采用这种锁定算法。 例如一个索引有9,11,13,20这4个值，那么该索引可能被Next-Key Locking的范围为（左开右闭 ）：
（1）(- &，9]
（2）(9,11]
（3）(13,20]
（4）(20,+ &)
* 可以显式的关闭Gap Lock：
（1）把事务隔离级别改成：Read Committed，提交读、不可重复读。(SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED);
（2）修改参数：innodb_locks_unsafe_for_binlog 设置为1。
[InnoDB锁算法详例](https://www.cnblogs.com/zhoujinyi/p/3435982.html "InnoDB锁算法详例")

-------------------------------------------------------
#### 大表优化
当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：
* 限定数据的范围；务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内
* 读/写分离；经典的数据库拆分方案，主库负责写，从库负责读；
* 垂直分区；根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 
（1）垂直拆分的优点：可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
（2）垂直拆分的缺点：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。
* 水平分区；保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。（MyCat和Sharding sphere）。

------------------------------------------------------------------------
#### 索引底层数据结构和算法








